# 分页实现

这篇文章展示了如何在我们的内核中实现分页支持。 它首先探讨了使内核可以访问物理页表帧的不同技术，并讨论了它们各自的优缺点。 然后它实现地址转换功能和创建新映射的功能。

本博客在 GitHub 上公开开发。 如果您有任何问题或疑问，请在那里打开一个问题来讨论。 您也可以在底部留下评论。 这篇文章的完整源代码可以在 post-09 分支中找到。

## 简介

上一篇文章介绍了分页的概念。通过将分页与分段进行比较来证明分页的优势，解释了分页和页表的工作原理，然后介绍了 x86_64 的 4 级页表设计。 我们发现引导加载程序 bootloader 已经为我们的内核设置了页表层次结构，这意味着我们的内核已经在虚拟地址上运行。 这提高了安全性，因为非法内存访问会导致页面错误异常，而不是修改任意物理内存。

上篇文章最后说我们无法从内核访问页表，因为它们存储在物理内存中并且我们的内核已经在虚拟地址上运行。 这篇文章探讨了使我们的内核可以访问页表帧的不同方法。 我们将讨论每种方法的优点和缺点，最后决定我们的内核采用哪种方法。

要实施该方法，我们需要引导加载程序的支持，因此我们将首先对其进行配置。 之后，我们将实现一个遍历页表层次结构的函数，以便将虚拟地址转换为物理地址。 最后，我们学习如何在页表中创建新的映射以及如何找到未使用的内存帧来创建新的页表。

## 访问页表

从我们的内核访问页表并不像看起来那么容易。 为了理解这个问题，让我们再次看一下上一篇文章中的示例：4 级页表层次结构：



这里重要的是每个页面条目存储下一个表的物理地址。 这就避免了对这些地址也进行翻译，这对性能不利并且很容易导致无休止的翻译循环。

我们的问题是我们不能直接从内核访问物理地址，因为我们的内核也在虚拟地址之上运行。 例如，当我们访问地址 4KiB 时，我们访问的是虚拟地址 4KiB，而不是存储 4 级页表的物理地址 4KiB。 当我们想要访问物理地址 4KiB 时，我们只能通过一些映射到它的虚拟地址来访问。

所以为了访问页表框架，我们需要将一些虚拟页面映射到它们。 有不同的方法来创建这些映射，这些映射都允许我们访问任意页表框架。

### 恒等映射

一个简单的解决方案是恒等映射所有页表：


在这个例子中，我们看到了各种恒等映射的页表帧。 这样，页表的物理地址也是有效的虚拟地址，这样我们就可以方便地访问从CR3寄存器开始的各级页表。

但是，它会使虚拟地址空间变得混乱，并且更难找到更大尺寸的连续内存区域。 例如，假设我们要在上图中创建一个大小为 1000 KiB 的虚拟内存区域，例如，用于文件的内存映射。 我们不能以 28KiB 开始该区域，因为它会与 1004KiB 的已映射页面发生冲突。 所以我们必须进一步寻找，直到找到足够大的未映射区域，例如 1008KiB。 这是与分段类似的碎片问题。

同样，这使得创建新页表变得更加困难，因为我们需要找到其对应页尚未使用的物理帧。 例如，假设我们为内存映射文件保留了从 1008KiB 开始的 1000KiB 虚拟内存区域。 现在我们不能再使用物理地址在 1000KiB 到 2008KiB 之间的任何帧，因为我们不能对它进行恒等映射。

### 以固定偏移量映射

为了避免虚拟地址空间混乱的问题，我们可以为页表映射使用一个单独的内存区域。 因此，我们不使用恒等映射页表框架，而是将它们映射到虚拟地址空间中的固定偏移量。 例如，偏移量可能是 10 TiB：


通过将 10 TiB..（10 TiB + 物理内存大小）范围内的虚拟内存专用于页表映射，我们避免了恒等映射的冲突问题。 仅当虚拟地址空间远大于物理内存大小时，才有可能保留如此大的虚拟地址空间区域。 这在 x86_64 上不是问题，因为 48 位地址空间有 256 TiB 大。

这种方法仍然有一个缺点，即我们需要在每次创建新页表时都创建一个新的映射。 此外，它不允许访问其他地址空间的页表，这在创建新进程时很有用。

### 映射完整的物理内存

我们可以通过映射完整的物理内存而不是仅仅映射页表框架来解决这些问题：


这种方法允许我们的内核访问任意物理内存，包括其他地址空间的页表帧。 保留的虚拟内存范围与以前的大小相同，不同之处在于它不再包含未映射的页面。

这种方法的缺点是需要额外的页表来存储物理内存的映射。 这些页表需要存储在某个地方，因此它们会占用一部分物理内存，这在内存量较小的设备上可能会出现问题。

然而，在 x86_64 上，我们可以使用大小为 2 MiB 的大页面进行映射，而不是默认的 4 KiB 页面。 这样，映射 32 GiB 的物理内存只需要 132 KiB 用于页表，因为只需要一个 3 级表和 32 个 2 级表。 大页面的缓存效率也更高，因为它们在转换后备缓冲区 (TLB) 中使用的条目较少。

### 临时映射

对于物理内存非常小的设备，我们可以仅在需要访问它们时临时映射页表框架。 为了能够创建临时映射，我们只需要一个身份映射级别 1 表：


此图中的 1 级表控制虚拟地址空间的前 2 MiB。 这是因为它可以通过从 CR3 寄存器开始并跟随第 4 级、第 3 级和第 2 级页表中的第 0 个条目来访问。 索引为 8 的条目将地址 32KiB 处的虚拟页映射到地址 32KiB 处的物理帧，从而标识映射 1 级表本身。 该图通过 32KiB 处的水平箭头显示了此标识映射。

通过写入身份映射一级表，我们的内核最多可以创建 511 个临时映射（512 减去身份映射所需的条目）。 在上面的例子中，内核创建了两个临时映射：

     通过将 1 级表的第 0 个条目映射到地址为 24KiB 的帧，它创建了 0KiB 处的虚拟页面到 2 级页表的物理帧的临时映射，如虚线箭头所示。
     通过将第 1 级表的第 9 个条目映射到地址为 4KiB 的帧，它创建了 36KiB 的虚拟页面到第 4 级页表的物理帧的临时映射，如虚线箭头所示。

现在内核可以通过写入页面 0KiB 来访问 2 级页表，通过写入页面 36KiB 来访问 4 级页表。

使用临时映射访问任意页表框架的过程是：

     在标识映射级别 1 表中搜索一个空闲条目。
     将该条目映射到我们要访问的页表的物理框架。
     通过映射到条目的虚拟页面访问目标框架。
     将条目设置回未使用状态，从而再次删除临时映射。

这种方法重复使用相同的 512 个虚拟页面来创建映射，因此只需要 4 KiB 的物理内存。 缺点是有点麻烦，尤其是一个新的映射可能需要修改多个表级别，这意味着我们需要多次重复上述过程。

### 递归页表

另一种有趣的方法是递归映射页表，它根本不需要额外的页表。 这种方法背后的想法是将一个条目从 4 级页表映射到 4 级表本身。 通过这样做，我们有效地保留了一部分虚拟地址空间，并将所有当前和未来的页表框架映射到该空间。

让我们通过一个例子来理解这一切是如何工作的：


与本文开头示例的唯一区别是 4 级表中索引 511 处的附加条目，它映射到物理帧 4KiB，即 4 级表本身的帧。

通过让 CPU 在翻译中跟随这个条目，它不会到达 3 级表，而是再次到达相同的 4 级表。 这类似于调用自身的递归函数，因此该表称为递归页表。 重要的是 CPU 假定 4 级表中的每个条目都指向 3 级表，因此它现在将 4 级表视为 3 级表。 这是可行的，因为所有级别的表在 x86_64 上都具有完全相同的布局。

通过在开始实际翻译之前执行一次或多次递归入口，我们可以有效地缩短 CPU 遍历的级别数。 比如我们按照递归入口一次，然后进行到3级表，CPU就认为3级表是2级表。 更进一步，它将 2 级表视为 1 级表，将 1 级表视为映射帧。 这意味着我们现在可以读写 1 级页表，因为 CPU 认为它是映射帧。 下图说明了五个翻译步骤：


类似地，我们可以在开始翻译之前跟随递归入口两次，以将遍历的层数减少到两层：


我们一步步来过：首先，CPU沿着4级表上的递归入口，认为到达了一个3级表。 然后它再次按照递归入口，认为它到达了一个2级表。 但实际上，它还在4级的桌子上。 当 CPU 现在跟随不同的条目时，它位于 3 级表但认为它已经在 1 级表上。 因此，当下一个条目指向 2 级表时，CPU 认为它指向映射帧，这允许我们读写 2 级表。

访问级别 3 和 4 的表的工作方式相同。 为了访问 3 级表，我们按照递归条目 3 次，让 CPU 认为它已经在 1 级表上。 然后我们跟随另一个条目到达 3 级表，CPU 将其视为映射帧。 为了访问 4 级表本身，我们只需跟随递归条目四次，直到 CPU 将 4 级表本身视为映射帧（下图中的蓝色部分）。


围绕这个概念可能需要一些时间，但它在实践中效果很好。

在下面的部分中，我们将解释如何构造虚拟地址以跟随递归条目一次或多次。 我们不会在我们的实现中使用递归分页，因此您无需阅读它即可继续本文。 如果您感兴趣，只需单击“地址计算”将其展开。

### 地址计算

我们看到，在实际翻译之前，我们可以通过一次或多次遵循递归条目来访问所有级别的表。 由于四级表的索引是直接从虚拟地址导出的，因此我们需要为该技术构造特殊的虚拟地址。 请记住，页表索引是通过以下方式从地址派生的：


假设我们要访问映射特定页面的 1 级页表。 正如我们在上面了解到的，这意味着在继续执行 4 级、3 级和 2 级索引之前，我们必须遵循递归条目一次。 为此，我们将地址的每个块向右移动一个块，并将原始的 4 级索引设置为递归条目的索引：

为了访问该页的 2 级表，我们将每个索引块向右移动两个块，并将原始 4 级索引和原始 3 级索引的块都设置为递归条目的索引：


通过将每个块向右移动三个块并使用原始 4 级、3 级和 2 级地址块的递归索引来访问 3 级表：


最后，我们可以通过将每个块向右移动四个块并对除偏移量之外的所有地址块使用递归索引来访问第 4 级表：


我们现在可以计算所有四个级别的页表的虚拟地址。 我们甚至可以通过将其索引乘以 8（页表条目的大小）来计算精确指向特定页表条目的地址。


下表总结了访问不同类型帧的地址结构：


而 AAA 是第 4 级索引，BBB 是第 3 级索引，CCC 是第 2 级索引，DDD 是映射帧的第 1 级索引，EEEE 是其中的偏移量。 RRR 是递归条目的索引。 当一个索引（三位数）转换为一个偏移量（四位数）时，它是通过将它乘以 8（页表条目的大小）来完成的。 使用此偏移量，生成的地址直接指向相应的页表条目。

SSSSSS是符号扩展位，意思是它们都是bit 47的副本。这是x86_64架构上对有效地址的特殊要求。 我们在上一篇文章中对此进行了解释。

我们使用八进制数来表示地址，因为每个八进制字符代表三位，这使我们能够清楚地分开不同页表级别的 9 位索引。 这在十六进制系统中是不可能的，其中每个字符代表四位。

在 Rust 代码中

要在 Rust 代码中构造此类地址，您可以使用按位运算：


上面的代码假定索引为 0o777 (511) 的最后一个 4 级条目被递归映射。 目前情况并非如此，因此代码还无法运行。 请参阅下文了解如何告诉引导加载程序设置递归映射。

除了手动执行按位操作之外，您还可以使用 x86_64 crate 的 RecursivePageTable 类型，它为各种页表操作提供了安全的抽象。 例如，下面的代码显示了如何将虚拟地址转换为其映射的物理地址：


同样，此代码需要有效的递归映射。 使用这样的映射，可以像第一个代码示例中那样计算缺少的 level_4_table_addr。

递归分页是一种有趣的技术，它展示了页表中的单个映射有多么强大。 它相对容易实现，只需要最少的设置（只需一个递归条目），因此它是第一次尝试分页的不错选择。

但是，它也有一些缺点：

    它占用了大量的虚拟内存（512 GiB）。 这在 48 位大地址空间中不是大问题，但可能会导致次优缓存行为。
    
    它只允许轻松访问当前活动的地址空间。 通过更改递归条目仍然可以访问其他地址空间，但是需要临时映射才能切换回  来。 我们在（过时的）Remap The Kernel 帖子中描述了如何执行此操作。
    
    它严重依赖于 x86 的页表格式，可能不适用于其他架构。



## 支持引导加载程序

所有这些方法都需要为它们的设置修改页表。 例如，需要创建物理内存的映射，或者需要递归映射 4 级表的条目。 问题是，如果没有现有的访问页表的方法，我们就无法创建这些必需的映射。

这意味着我们需要引导加载程序的帮助，它创建我们的内核运行的页表。 引导加载程序可以访问页表，因此它可以创建我们需要的任何映射。 在当前的实现中，bootloader crate 支持上述两种方法，通过 cargo features 控制：

     map_physical_memory 特性将某处的完整物理内存映射到虚拟地址空间。 因此，内核可以访问所有物理内存，并且可以遵循映射完整物理内存的方法。
     
     使用 recursive_page_table 功能，引导加载程序递归地映射 4 级页表的条目。 这允许内核访问页表，如递归页表部分所述。

我们为内核选择第一种方法，因为它简单、平台无关且功能更强大（它还允许访问非页表框架）。 为了启用所需的引导加载程序支持，我们将 map_physical_memory 功能添加到我们的引导加载程序依赖项中：


启用此功能后，引导加载程序将完整的物理内存映射到一些未使用的虚拟地址范围。 为了将虚拟地址范围传达给我们的内核，引导加载程序传递了一个引导信息结构。

### 引导信息

引导加载程序 crate 定义了一个 BootInfo 结构，其中包含它传递给我们内核的所有信息。 该结构仍处于早期阶段，因此在更新到未来与 semver 不兼容的引导加载程序版本时预计会出现一些破损。 启用map_physical_memory特性后，它目前有两个字段memory_map和physical_memory_offset：

     memory_map 字段包含可用物理内存的概览。 这告诉我们的内核系统中有多少物理内存可用，以及哪些内存区域是为 VGA 硬件等设备保留的。 可以从 BIOS 或 UEFI 固件查询内存映射，但只能在启动过程的早期。 因此，它必须由引导加载程序提供，因为内核稍后无法检索它。 我们将在本文后面需要内存映射。

     physical_memory_offset 告诉我们物理内存映射的虚拟起始地址。 通过将此偏移量添加到物理地址，我们得到相应的虚拟地址。 这允许我们从内核访问任意物理内存。

     可以通过在 Cargo.toml 中添加 [package.metadata.bootloader] 表并设置字段 physical-memory-offset = "0x0000f00000000000"（或任何其他值）来自定义此物理内存偏移量。 但是，请注意，如果引导加载程序遇到开始与偏移量以外的空间重叠的物理地址值，即它以前映射到其他早期物理地址的区域，则它可能会崩溃。 所以一般来说，值越高（> 1 TiB）越好。

引导加载程序以 &'static BootInfo 参数的形式将 BootInfo 结构传递给我们的内核到我们的 _start 函数。 我们还没有在我们的函数中声明这个参数，所以让我们添加它：


之前放弃这个参数不是问题，因为 x86_64 调用约定在 CPU 寄存器中传递第一个参数。 因此，参数在未声明时会被简单地忽略。 但是，如果我们不小心使用了错误的参数类型，那将是一个问题，因为编译器不知道我们入口函数的正确类型签名。

### 入口点宏

由于我们的 _start 函数是从引导加载程序外部调用的，因此不会检查我们的函数签名。 这意味着我们可以让它接受任意参数而不会出现任何编译错误，但它会在运行时失败或导致未定义的行为。

为了确保入口点函数始终具有引导加载程序期望的正确签名，引导加载程序 crate 提供了一个 entry_point 宏，它提供了一种类型检查的方式来将 Rust 函数定义为入口点。 让我们重写我们的入口点函数来使用这个宏：


我们不再需要使用 extern "C" 或 no_mangle 作为我们的入口点，因为宏为我们定义了真正的较低级别的 _start 入口点。 kernel_main 函数现在是一个完全正常的 Rust 函数，因此我们可以为它选择任意名称。 重要的是它是类型检查的，因此当我们使用错误的函数签名时会发生编译错误，例如通过添加参数或更改参数类型。

让我们在 lib.rs 中执行相同的更改：


由于入口点仅在测试模式下使用，我们将 #[cfg(test)] 属性添加到所有项目。 我们给我们的测试入口点一个不同的名称 test_kernel_main 以避免与我们的 main.rs 的 kernel_main 混淆。 我们暂时不使用 BootInfo 参数，所以我们在参数名称前加上一个 _ 来消除未使用变量警告。

### 执行

现在我们可以访问物理内存了，我们终于可以开始实现我们的页表代码了。 首先，我们将查看我们的内核运行的当前活动页表。 在第二步中，我们将创建一个转换函数，该函数返回给定虚拟地址映射到的物理地址。 作为最后一步，我们将尝试修改页表以创建新映射。

在我们开始之前，我们为我们的代码创建一个新的内存模块：


对于模块，我们创建一个空的 src/memory.rs 文件。

### 访问页表

在上一篇文章的结尾，我们试图查看内核运行的页表，但失败了，因为我们无法访问 CR3 寄存器指向的物理帧。 我们现在可以从那里继续创建一个 active_level_4_table 函数，该函数返回对活动 4 级页表的引用：


首先，我们从CR3寄存器中读取active level 4表的物理帧。 然后我们获取它的物理起始地址，将其转换为u64，并将其添加到physical_memory_offset以获得页表框架映射到的虚拟地址。 最后，我们通过 as_mut_ptr 方法将虚拟地址转换为 *mut PageTable 原始指针，然后从中不安全地创建一个 &mut PageTable 引用。 我们创建一个 &mut 引用而不是 & 引用，因为我们将在本文后面修改页表。

我们不需要在这里使用不安全块，因为 Rust 将不安全 fn 的完整主体视为一个大的不安全块。 这使我们的代码更加危险，因为我们可能会在不注意的情况下不小心在前面的行中引入不安全的操作。 这也使得在安全操作之间发现不安全操作变得更加困难。 有一个 RFC 可以更改此行为。

我们现在可以使用这个函数来打印 4 级表的条目：


首先，我们将 BootInfo 结构的 physical_memory_offset 转换为 VirtAddr 并将其传递给 active_level_4_table 函数。 然后我们使用 iter 函数迭代页表条目，并使用枚举组合器为每个元素额外添加一个索引 i。 我们只打印非空条目，因为所有 512 个条目都无法显示在屏幕上。

当我们运行它时，我们会看到以下输出：


我们看到有各种非空条目，它们都映射到不同的 3 级表。 有这么多区域是因为内核代码、内核堆栈、物理内存映射和引导信息都使用单独的内存区域。

要进一步遍历页表并查看 3 级表，我们可以获取条目的映射帧并将其再次转换为虚拟地址：


为了查看 2 级和 1 级表，我们对 3 级和 2 级条目重复该过程。 正如您所想象的，这很快就会变得非常冗长，所以我们不会在这里显示完整的代码。

手动遍历页表很有趣，因为它有助于理解 CPU 如何执行转换。 然而，大多数时候，我们只对给定虚拟地址的映射物理地址感兴趣，所以让我们为此创建一个函数。

### 翻译地址

要将虚拟地址转换为物理地址，我们必须遍历四级页表，直到到达映射帧。 让我们创建一个执行此翻译的函数：


我们将该函数转发给一个安全的 translate_addr_inner 函数来限制不安全的范围。 正如我们上面提到的，Rust 将不安全 fn 的完整主体视为一个大的不安全块。 通过调用私有安全函数，我们再次明确了每个不安全操作。

私有内部函数包含真正的实现：


我们没有重新使用我们的 active_level_4_table 函数，而是再次从 CR3 寄存器中读取 4 级帧。 我们这样做是因为它简化了这个原型的实现。 别担心，我们稍后会创建更好的解决方案。

VirtAddr 结构已经提供了将索引计算到四个级别的页表中的方法。 我们将这些索引存储在一个小数组中，因为它允许我们使用 for 循环遍历页表。 在循环之外，我们记住最后访问的帧以便稍后计算物理地址。 该框架在迭代时指向页表框架，并在最后一次迭代后指向映射的框架，即在第 1 级条目之后。

在循环内部，我们再次使用 physical_memory_offset 将帧转换为页表引用。 然后我们读取当前页表的条目并使用 PageTableEntry::frame 函数来检索映射的帧。 如果条目未映射到帧，则返回 None。 如果该条目映射了一个巨大的 2 MiB 或 1 GiB 页面，我们现在会感到恐慌。

让我们通过翻译一些地址来测试我们的翻译功能：


当我们运行它时，我们会看到以下输出：


正如预期的那样，身份映射地址 0xb8000 转换为相同的物理地址。 代码页和堆栈页转换为一些任意物理地址，这取决于引导加载程序如何为我们的内核创建初始映射。 值得注意的是，最后 12 位在翻译后始终保持不变，这是有道理的，因为这些位是页面偏移量，而不是翻译的一部分。

由于每个物理地址都可以通过添加physical_memory_offset来访问，所以physical_memory_offset地址本身的翻译应该指向物理地址0。但是，翻译失败，因为映射使用大页面来提高效率，这在我们的实现中尚不支持。

### 使用偏移页表

将虚拟地址转换为物理地址是操作系统内核中的一项常见任务，因此 x86_64 crate 为其提供了抽象。 除了 translate_addr 之外，该实现已经支持大页面和其他几个页表函数，因此我们将在下面使用它，而不是在我们自己的实现中添加大页面支持。

抽象的基础是定义各种页表映射函数的两个特征：

     Mapper 特征在页面大小上是通用的，并提供在页面上操作的函数。 示例是 translate_page，它将给定页面转换为相同大小的框架，以及 map_to，它在页表中创建新映射。

     Translate 特性提供了适用于多种页面大小的函数，例如 translate_addr 或通用的 translate。

traits 只定义接口，不提供任何实现。 x86_64 crate 目前提供了三种类型来实现不同需求的 traits。 OffsetPageTable 类型假定完整的物理内存以某个偏移量映射到虚拟地址空间。 MappedPageTable 更灵活一些：它只需要将每个页表框架映射到一个可计算地址的虚拟地址空间。 最后，RecursivePageTable 类型可用于通过递归页表访问页表框架。

在我们的例子中，引导加载程序将完整的物理内存映射到由 physical_memory_offset 变量指定的虚拟地址，因此我们可以使用 OffsetPageTable 类型。 为了初始化它，我们在内存模块中创建了一个新的 init 函数：


该函数将 physical_memory_offset 作为参数并返回一个具有 'static 生命周期的新 OffsetPageTable 实例。 这意味着该实例在我们内核的整个运行时保持有效。 在函数体中，我们首先调用 active_level_4_table 函数来检索对 4 级页表的可变引用。 然后我们用这个引用调用 OffsetPageTable::new 函数。 作为第二个参数，新函数需要物理内存映射开始的虚拟地址，该地址在 physical_memory_offset 变量中给出。

从现在开始，active_level_4_table 函数应该只从 init 函数中调用，因为它在多次调用时很容易导致别名可变引用，这会导致未定义的行为。 出于这个原因，我们通过删除 pub 说明符将函数设为私有。

我们现在可以使用 Translate::translate_addr 方法代替我们自己的 memory::translate_addr 函数。 我们只需要更改 kernel_main 中的几行：


我们需要导入 Translate 特性才能使用它提供的 translate_addr 方法。

当我们现在运行它时，我们看到与以前相同的翻译结果，不同之处在于大页面翻译现在也可以工作：


正如预期的那样，0xb8000 的翻译以及代码和堆栈地址与我们自己的翻译函数保持相同。 此外，我们现在看到虚拟地址 physical_memory_offset 映射到物理地址 0x0。

通过使用 MappedPageTable 类型的翻译功能，我们可以省去实现大页面支持的工作。 我们还可以访问其他页面函数，例如我们将在下一节中使用的 map_to。

此时，我们不再需要我们的 memory::translate_addr 和 memory::translate_addr_inner 函数，所以我们可以删除它们。

### 创建一个新的映射

到目前为止，我们只查看了页表而没有修改任何内容。 让我们通过为以前未映射的页面创建新映射来改变它。

我们将使用 Mapper trait 的 map_to 函数来实现我们的实现，所以让我们先看一下该函数。 文档告诉我们它有四个参数：我们要映射的页面、页面应该映射到的框架、页表条目的一组标志和一个 frame_allocator。 需要帧分配器是因为映射给定页面可能需要创建额外的页表，这需要未使用的帧作为后备存储。

### 一个 create_example_mapping 函数

我们实现的第一步是创建一个新的 create_example_mapping 函数，它将给定的虚拟页面映射到 0xb8000，即 VGA 文本缓冲区的物理帧。 我们选择该框架是因为它允许我们轻松测试映射是否正确创建：我们只需要写入新映射的页面并查看我们是否看到写入出现在屏幕上。

create_example_mapping 函数如下所示：


除了应映射的页面之外，该函数还需要对 OffsetPageTable 实例和 frame_allocator 的可变引用。 frame_allocator 参数使用 impl Trait 语法对实现 FrameAllocator 特征的所有类型通用。 该特性比 PageSize 特性更通用，可用于标准的 4 KiB 页面和巨大的 2 MiB/1 GiB 页面。 我们只想创建一个 4 KiB 映射，因此我们将通用参数设置为 Size4KiB。

map_to 方法是不安全的，因为调用者必须确保该框架尚未被使用。 这样做的原因是两次映射同一帧可能会导致未定义的行为，例如当两个不同的 &mut 引用指向同一物理内存位置时。 在我们的例子中，我们重用了已经映射的 VGA 文本缓冲区帧，因此我们打破了要求的条件。 不过create_example_mapping函数只是一个临时测试函数，发完后会去掉，所以没问题。 为了提醒我们不安全，我们在线上添加了 FIXME 注释。

除了页面和 unused_frame 之外，map_to 方法还采用了一组用于映射的标志和对 frame_allocator 的引用，稍后将对此进行解释。 对于标志，我们设置了 PRESENT 标志，因为它是所有有效条目所必需的，并且设置了 WRITABLE 标志以使映射页面可写。 有关所有可能标志的列表，请参阅上一篇文章的页表格式部分。

map_to 函数可能会失败，因此它会返回一个结果。 由于这只是一些不需要健壮的示例代码，我们只是使用 expect 在发生错误时恐慌。 成功时，该函数返回一个 MapperFlush 类型，该类型提供了一种使用其 flush 方法从转换后备缓冲区 (TLB) 刷新新映射页面的简单方法。 与 Result 一样，该类型使用 #[must_use] 属性在我们不小心忘记使用它时发出警告。

### 一个虚拟的 FrameAllocator

为了能够调用 create_example_mapping，我们需要先创建一个实现 FrameAllocator 特性的类型。 如上所述，如果 map_to 需要，该特征负责为新页表分配帧。

让我们从简单的案例开始，假设我们不需要创建新的页表。 对于这种情况，始终返回 None 的帧分配器就足够了。 我们创建这样一个 EmptyFrameAllocator 来测试我们的映射函数：


实现 FrameAllocator 是不安全的，因为实现者必须保证分配器只产生未使用的帧。 否则，可能会发生未定义的行为，例如当两个虚拟页面映射到同一个物理框架时。 我们的 EmptyFrameAllocator 只返回 None，所以在这种情况下这不是问题。

### 选择虚拟页面

我们现在有一个简单的帧分配器，我们可以将其传递给我们的 create_example_mapping 函数。 但是，分配器总是返回 None，所以这只有在不需要额外的页表框架来创建映射时才有效。 要了解何时需要以及何时不需要额外的页表框架，让我们考虑一个示例：


图中左边是虚拟地址空间，右边是物理地址空间，中间是页表。 页表存储在物理内存帧中，如虚线所示。 虚拟地址空间包含地址为 0x803fe00000 的单个映射页面，标记为蓝色。 为了将此页面转换为其帧，CPU 遍历 4 级页表，直到它到达地址为 36 KiB 的帧。

此外，图形以红色显示 VGA 文本缓冲区的物理帧。 我们的目标是使用我们的 create_example_mapping 函数将以前未映射的虚拟页面映射到此框架。 由于我们的 EmptyFrameAllocator 始终返回 None，因此我们希望创建映射，以便分配器不需要额外的帧。 这取决于我们为映射选择的虚拟页面。

该图显示了虚拟地址空间中的两个候选页面，均以黄色标记。 一页位于地址 0x803fdfd000，即映射页（蓝色）之前的 3 页。 虽然 4 级和 3 级页表索引与蓝页相同，但 2 级和 1 级索引不同（请参阅上一篇文章）。 2 级表中的不同索引意味着此页使用不同的 1 级表。 由于此 1 级表尚不存在，如果我们为示例映射选择该页面，则需要创建它，这将需要一个额外的未使用的物理框架。 相比之下，地址为0x803fe02000的第二个候选页则没有这个问题，因为它使用了和蓝页一样的一级页表。 因此，所有需要的页表都已经存在。

总之，创建新映射的难度取决于我们要映射的虚拟页面。 在最简单的情况下，页面的 1 级页表已经存在，我们只需要编写一个条目即可。 在最困难的情况下，页面位于尚不存在第 3 级的内存区域中，因此我们需要先创建新的第 3 级、第 2 级和第 1 级页表。

为了使用 EmptyFrameAllocator 调用我们的 create_example_mapping 函数，我们需要选择一个所有页表都已经存在的页。 要找到这样一个页面，我们可以利用引导加载程序将自身加载到虚拟地址空间的第一个兆字节这一事实。 这意味着该区域中的所有页面都存在一个有效的 1 级表。 因此，我们可以为我们的示例映射选择该内存区域中任何未使用的页面，例如地址 0 处的页面。通常，该页面应保持未使用状态以保证取消引用空指针会导致页面错误，因此我们知道引导加载程序 使其未映射。

### 创建映射

我们现在拥有调用 create_example_mapping 函数所需的所有参数，所以让我们修改 kernel_main 函数以将页面映射到虚拟地址 0。由于我们将页面映射到 VGA 文本缓冲区的帧，我们应该能够写入 之后筛选它。 实现看起来像这样：


我们首先通过使用对映射器和 frame_allocator 实例的可变引用调用我们的 create_example_mapping 函数来为地址 0 处的页面创建映射。 这会将页面映射到 VGA 文本缓冲区帧，因此我们应该在屏幕上看到对它的任何写入。

然后我们将页面转换为原始指针并将值写入偏移量 400。我们不写入页面的开头，因为 VGA 缓冲区的顶行被下一个 println 直接移出屏幕。 我们写入值 0x_f021_f077_f065_f04e，代表字符串“New!” 在白色背景上。 正如我们在“VGA 文本模式”一文中了解到的，对 VGA 缓冲区的写入应该是易失的，因此我们使用 write_volatile 方法。

当我们在 QEMU 中运行它时，我们会看到以下输出：


新的！” 屏幕上的 是我们对页 0 的写入引起的，这意味着我们成功地在页表中创建了一个新映射。

创建该映射之所以有效，是因为负责地址 0 处页面的 1 级表已经存在。 当我们尝试映射一个尚不存在 1 级表的页时，map_to 函数失败，因为它试图通过使用 EmptyFrameAllocator 分配帧来创建新的页表。 当我们尝试映射页面 0xdeadbeaf000 而不是 0 时，我们可以看到发生了这种情况：


当我们运行它时，会出现带有以下错误消息的恐慌：


要映射还没有一级页表的页面，我们需要创建一个合适的 FrameAllocator。 但是我们如何知道哪些帧未使用以及有多少物理内存可用？

### 分配帧

为了创建新的页表，我们需要创建一个合适的帧分配器。 为此，我们使用引导加载程序传递的 memory_map 作为 BootInfo 结构的一部分：


该结构有两个字段：一个是对引导加载程序传递的内存映射的静态引用，另一个是跟踪分配器应返回的下一帧编号的下一个字段。

正如我们在引导信息部分中解释的那样，内存映射由 BIOS/UEFI 固件提供。 它只能在引导过程的很早的时候查询，所以引导加载程序已经为我们调用了相应的函数。 内存映射由一系列 MemoryRegion 结构组成，其中包含每个内存区域的起始地址、长度和类型（例如未使用、保留等）。

init 函数使用给定的内存映射初始化 BootInfoFrameAllocator。 下一个字段用 0 初始化，并将在每次帧分配时增加，以避免两次返回相同的帧。 由于我们不知道内存映射的可用帧是否已在其他地方使用，因此我们的 init 函数必须不安全才能要求调用者提供额外的保证。

### 一个 usable_frames 方法

在我们实现 FrameAllocator 特性之前，我们添加一个辅助方法，将内存映射转换为可用帧的迭代器：


此函数使用迭代器组合器方法将初始 MemoryMap 转换为可用物理帧的迭代器：

     首先，我们调用 iter 方法将内存映射转换为 MemoryRegions 的迭代器。

     然后我们使用 filter 方法跳过任何保留或不可用的区域。 引导加载程序会为其创建的所有映射更新内存映射，因此我们的内核（代码、数据或堆栈）使用或存储引导信息的帧已标记为 InUse 或类似的。 因此，我们可以确定 Usable frames 没有在其他地方使用。

     之后，我们使用 map 组合器和 Rust 的范围语法将我们的内存区域迭代器转换为地址范围迭代器。

     接下来，我们使用 flat_map 将地址范围转换为帧起始地址的迭代器，使用 step_by 选择每个第 4096 个地址。 由于 4096 字节（= 4 KiB）是页面大小，我们得到每个帧的起始地址。 引导加载程序页面对齐所有可用的内存区域，因此我们在这里不需要任何对齐或舍入代码。 通过使用 flat_map 而不是 map，我们得到了一个 Iterator<Item = u64> 而不是 Iterator<Item = Iterator<Item = u64>>。

     最后，我们将起始地址转换为 PhysFrame 类型以构造一个 Iterator<Item = PhysFrame>。

函数的返回类型使用 impl Trait 特性。 这样，我们可以指定我们返回一些实现 Iterator 特性的类型，项目类型为 PhysFrame，但不需要命名具体的返回类型。 这在这里很重要，因为我们不能命名具体类型，因为它依赖于不可命名的闭包类型。

### 实现 FrameAllocator 特性

现在我们可以实现 FrameAllocator 特性：


我们首先使用 usable_frames 方法从内存映射中获取可用帧的迭代器。 然后，我们使用 Iterator::nth 函数获取索引为 self.next 的帧（从而跳过 (self.next - 1) 帧）。 在返回该帧之前，我们将 self.next 加一，以便在下一次调用时返回下一帧。

这个实现不是很理想，因为它在每次分配时都会重新创建 usable_frame 分配器。 最好将迭代器直接存储为结构字段。 这样我们就不需要第 n 个方法，可以在每次分配时调用 next。 这种方法的问题是目前无法在结构字段中存储 impl Trait 类型。 当命名的存在类型被完全实现时，它可能会在某一天起作用。

### 使用 BootInfoFrameAllocator

我们现在可以修改我们的 kernel_main 函数来传递一个 BootInfoFrameAllocator 实例而不是 EmptyFrameAllocator：


使用引导信息帧分配器，映射成功，我们看到黑白“New！” 再次出现在屏幕上。 在幕后，map_to 方法通过以下方式创建缺失的页表：

     使用传递的 frame_allocator 分配未使用的帧。

     将框架归零以创建一个新的空页表。

     将更高级别表的条目映射到该帧。

     继续下一个表级别。

虽然我们的 create_example_mapping 函数只是一些示例代码，但我们现在能够为任意页面创建新的映射。 这对于在以后的帖子中分配内存或实现多线程至关重要。

此时，我们应该再次删除 create_example_mapping 函数，以避免意外调用未定义的行为，如上所述。

## 总结

在这篇文章中，我们了解了访问页表物理帧的不同技术，包括恒等映射、完整物理内存的映射、临时映射和递归页表。 我们选择映射完整的物理内存，因为它简单、便携且功能强大。

如果没有页表访问，我们无法从内核映射物理内存，因此我们需要引导加载程序的支持。 bootloader crate 支持通过可选的 cargo crate 功能创建所需的映射。 它以 &BootInfo 参数的形式将所需信息传递给我们的内核，并将其传递给我们的入口点函数。

对于我们的实现，我们首先手动遍历页表以实现翻译功能，然后使用 x86_64 crate 的 MappedPageTable 类型。 我们还学习了如何在页表中创建新映射，以及如何在引导加载程序传递的内存映射之上创建必要的 FrameAllocator。

## 下篇预览

下一篇文章将为我们的内核创建一个堆内存区域，这将允许我们分配内存和使用各种集合类型。
